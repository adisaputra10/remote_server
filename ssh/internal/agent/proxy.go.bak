package agent

import (
	"fmt"
	"io"
	"net"
	"time"

	"ssh-terminal/internal/proto"
)

// start starts the database proxy
func (dp *DatabaseProxy) start() error {
	addr := fmt.Sprintf(":%d", dp.LocalPort)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		return fmt.Errorf("failed to listen on %s: %w", addr, err)
	}

	dp.listener = listener

	// Start accepting connections
	go dp.acceptConnections()

	return nil
}

// stop stops the database proxy
func (dp *DatabaseProxy) stop() {
	dp.cancel()
	if dp.listener != nil {
		dp.listener.Close()
	}
}

// acceptConnections accepts and handles incoming connections
func (dp *DatabaseProxy) acceptConnections() {
	defer dp.agent.logger.Printf("üîö Database proxy %s stopped", dp.Name)

	for {
		select {
		case <-dp.ctx.Done():
			return
		default:
		}

		conn, err := dp.listener.Accept()
		if err != nil {
			if dp.ctx.Err() != nil {
				return // Context cancelled
			}
			dp.agent.logger.Printf("‚ùå Failed to accept connection on proxy %s: %v", dp.Name, err)
			continue
		}

		// Handle connection in goroutine
		go dp.handleConnection(conn)
	}
}

// handleConnection handles an individual database connection
func (dp *DatabaseProxy) handleConnection(clientConn net.Conn) {
	defer clientConn.Close()

	sessionID := fmt.Sprintf("session_%x", time.Now().UnixNano())
	clientIP := clientConn.RemoteAddr().String()

	dp.agent.logger.Printf("üì° New %s connection: %s (session: %s)", dp.Protocol, clientIP, sessionID)

	// Connect to target database
	targetAddr := fmt.Sprintf("%s:%d", dp.TargetHost, dp.TargetPort)
	targetConn, err := net.Dial("tcp", targetAddr)
	if err != nil {
		dp.agent.logger.Printf("‚ùå Failed to connect to target %s: %v", targetAddr, err)
		return
	}
	defer targetConn.Close()

	dp.agent.logger.Printf("‚úÖ Connected to target %s", targetAddr)

	// Start bidirectional forwarding with inspection
	done := make(chan bool, 2)

	// Client -> Server
	go func() {
		defer func() { done <- true }()
		dp.forwardWithInspection(clientConn, targetConn, "client->server", sessionID, clientIP)
	}()

	// Server -> Client
	go func() {
		defer func() { done <- true }()
		dp.forwardWithInspection(targetConn, clientConn, "server->client", sessionID, clientIP)
	}()

	// Wait for either direction to close
	<-done
	dp.agent.logger.Printf("üîö Connection closed: %s", sessionID)
}

// forwardWithInspection forwards data while inspecting for database commands
func (dp *DatabaseProxy) forwardWithInspection(src, dst net.Conn, direction, sessionID, clientIP string) {
	buffer := make([]byte, 32*1024) // 32KB buffer

	for {
		// Set read timeout
		src.SetReadDeadline(time.Now().Add(5 * time.Minute))

		n, err := src.Read(buffer)
		if err != nil {
			if err != io.EOF {
				dp.agent.logger.Printf("‚ùå Read error in %s (%s): %v", direction, sessionID, err)
			}
			return
		}

		data := buffer[:n]

		// Inspect data for database commands (only from client)
		if direction == "client->server" {
			dp.inspectDatabaseCommands(data, sessionID, clientIP)
		}

		// Forward data
		dst.SetWriteDeadline(time.Now().Add(30 * time.Second))
		_, err = dst.Write(data)
		if err != nil {
			dp.agent.logger.Printf("‚ùå Write error in %s (%s): %v", direction, sessionID, err)
			return
		}
	}
}

// inspectDatabaseCommands inspects data for database commands and logs them
func (dp *DatabaseProxy) inspectDatabaseCommands(data []byte, sessionID, clientIP string) {
	var command string

	switch dp.Protocol {
	case "mysql":
		command = dp.extractMySQLCommand(data)
	case "postgres", "postgresql":
		command = dp.extractPostgreSQLCommand(data)
	default:
		return
	}

	if command != "" {
		dp.agent.logger.Printf("üìù DB_COMMAND [%s]: %s | %s | %s | %s",
			dp.agent.config.Name, sessionID, command, dp.Protocol, clientIP)

		// Send database command to server for logging
		msg := proto.NewMessage(proto.MessageTypeDatabaseCommand)
		msg.SessionID = sessionID
		msg.AgentID = dp.agent.config.ID
		msg.Data = &proto.DatabaseCommand{
			SessionID: sessionID,
			AgentID:   dp.agent.config.ID,
			Command:   command,
			Protocol:  dp.Protocol,
			ClientIP:  clientIP,
			ProxyName: dp.Name,
			Metadata:  make(map[string]interface{}),
			Timestamp: time.Now(),
		}

		dp.agent.sendMessage(msg)
	}
}

// extractMySQLCommand extracts SQL command from MySQL protocol data
func (dp *DatabaseProxy) extractMySQLCommand(data []byte) string {
	if len(data) < 5 {
		return ""
	}

	// MySQL packet format: [length:3][sequence:1][command:1][data...]
	if data[4] == 0x03 { // COM_QUERY
		command := string(data[5:])
		// Clean up the command
		if len(command) > 500 {
			command = command[:500] + "..."
		}
		return command
	}

	return ""
}

// extractPostgreSQLCommand extracts SQL command from PostgreSQL protocol data
func (dp *DatabaseProxy) extractPostgreSQLCommand(data []byte) string {
	if len(data) < 5 {
		return ""
	}

	// PostgreSQL message format varies, basic query detection
	if data[0] == 'Q' { // Simple query
		command := string(data[5:])
		// Clean up the command
		if len(command) > 500 {
			command = command[:500] + "..."
		}
		return command
	}

	return ""
}

// start starts the tunnel data forwarding
func (t *Tunnel) start() {
	defer t.stop()

	done := make(chan bool, 2)

	// Agent -> Target
	go func() {
		defer func() { done <- true }()
		io.Copy(t.TargetConn, t.AgentConn)
	}()

	// Target -> Agent
	go func() {
		defer func() { done <- true }()
		io.Copy(t.AgentConn, t.TargetConn)
	}()

	// Wait for either direction to close
	select {
	case <-done:
	case <-t.ctx.Done():
	}
}

// stop stops the tunnel
func (t *Tunnel) stop() {
	if t.cancel != nil {
		t.cancel()
	}
	if t.AgentConn != nil {
		t.AgentConn.Close()
	}
	if t.TargetConn != nil {
		t.TargetConn.Close()
	}
}
